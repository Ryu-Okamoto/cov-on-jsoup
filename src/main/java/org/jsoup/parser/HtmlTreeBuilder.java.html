
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>src/main/java/org/jsoup/parser/HtmlTreeBuilder.java</title>
<link rel="stylesheet" href="../../../../../../__resource__/styles.css" type="text/css">
</head>
<body>
<div class="directory">
<a href="../../../../../index.html">src</a>/<a href="../../../../index.html">main</a>/<a href="../../../index.html">java</a>/<a href="../../index.html">org</a>/<a href="../index.html">jsoup</a>/<a href="index.html">parser</a>/HtmlTreeBuilder.java
</div>
<div class="viewer">
<pre class="source-code" id="source-code">package org.jsoup.parser;

import org.jsoup.helper.Validate;
import org.jsoup.internal.Normalizer;
import org.jsoup.internal.StringUtil;
import org.jsoup.nodes.Attributes;
import org.jsoup.nodes.CDataNode;
import org.jsoup.nodes.Comment;
import org.jsoup.nodes.DataNode;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.FormElement;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jspecify.annotations.Nullable;

import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import static org.jsoup.internal.StringUtil.inSorted;
import static org.jsoup.parser.HtmlTreeBuilderState.Constants.InTableFoster;
import static org.jsoup.parser.HtmlTreeBuilderState.ForeignContent;
import static org.jsoup.parser.Parser.NamespaceHtml;

/**
 * HTML Tree Builder; creates a DOM from Tokens.
 */
<span id="H0">public class HtmlTreeBuilder extends TreeBuilder {</span>
    // tag searches. must be sorted, used in inSorted. HtmlTreeBuilderTest validates they&#x27;re sorted.
<span id="H0">    static final String[] TagsSearchInScope = new String[]{&quot;applet&quot;, &quot;caption&quot;, &quot;html&quot;, &quot;marquee&quot;, &quot;object&quot;, &quot;table&quot;, &quot;td&quot;, &quot;th&quot;};</span>
<span id="H0">    static final String[] TagSearchList = new String[]{&quot;ol&quot;, &quot;ul&quot;};</span>
<span id="H0">    static final String[] TagSearchButton = new String[]{&quot;button&quot;};</span>
<span id="H0">    static final String[] TagSearchTableScope = new String[]{&quot;html&quot;, &quot;table&quot;};</span>
<span id="H0">    static final String[] TagSearchSelectScope = new String[]{&quot;optgroup&quot;, &quot;option&quot;};</span>
<span id="H0">    static final String[] TagSearchEndTags = new String[]{&quot;dd&quot;, &quot;dt&quot;, &quot;li&quot;, &quot;optgroup&quot;, &quot;option&quot;, &quot;p&quot;, &quot;rb&quot;, &quot;rp&quot;, &quot;rt&quot;, &quot;rtc&quot;};</span>
<span id="H0">    static final String[] TagThoroughSearchEndTags = new String[]{&quot;caption&quot;, &quot;colgroup&quot;, &quot;dd&quot;, &quot;dt&quot;, &quot;li&quot;, &quot;optgroup&quot;, &quot;option&quot;, &quot;p&quot;, &quot;rb&quot;, &quot;rp&quot;, &quot;rt&quot;, &quot;rtc&quot;, &quot;tbody&quot;, &quot;td&quot;, &quot;tfoot&quot;, &quot;th&quot;, &quot;thead&quot;, &quot;tr&quot;};</span>
<span id="H0">    static final String[] TagSearchSpecial = new String[]{&quot;address&quot;, &quot;applet&quot;, &quot;area&quot;, &quot;article&quot;, &quot;aside&quot;, &quot;base&quot;, &quot;basefont&quot;, &quot;bgsound&quot;,</span>
        &quot;blockquote&quot;, &quot;body&quot;, &quot;br&quot;, &quot;button&quot;, &quot;caption&quot;, &quot;center&quot;, &quot;col&quot;, &quot;colgroup&quot;, &quot;command&quot;, &quot;dd&quot;,
        &quot;details&quot;, &quot;dir&quot;, &quot;div&quot;, &quot;dl&quot;, &quot;dt&quot;, &quot;embed&quot;, &quot;fieldset&quot;, &quot;figcaption&quot;, &quot;figure&quot;, &quot;footer&quot;, &quot;form&quot;,
        &quot;frame&quot;, &quot;frameset&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;head&quot;, &quot;header&quot;, &quot;hgroup&quot;, &quot;hr&quot;, &quot;html&quot;,
        &quot;iframe&quot;, &quot;img&quot;, &quot;input&quot;, &quot;isindex&quot;, &quot;li&quot;, &quot;link&quot;, &quot;listing&quot;, &quot;marquee&quot;, &quot;menu&quot;, &quot;meta&quot;, &quot;nav&quot;,
        &quot;noembed&quot;, &quot;noframes&quot;, &quot;noscript&quot;, &quot;object&quot;, &quot;ol&quot;, &quot;p&quot;, &quot;param&quot;, &quot;plaintext&quot;, &quot;pre&quot;, &quot;script&quot;,
        &quot;section&quot;, &quot;select&quot;, &quot;style&quot;, &quot;summary&quot;, &quot;table&quot;, &quot;tbody&quot;, &quot;td&quot;, &quot;textarea&quot;, &quot;tfoot&quot;, &quot;th&quot;, &quot;thead&quot;,
        &quot;title&quot;, &quot;tr&quot;, &quot;ul&quot;, &quot;wbr&quot;, &quot;xmp&quot;};
<span id="H0">    static final String[] TagMathMlTextIntegration = new String[]{&quot;mi&quot;, &quot;mn&quot;, &quot;mo&quot;, &quot;ms&quot;, &quot;mtext&quot;};</span>
<span id="H0">    static final String[] TagSvgHtmlIntegration = new String[]{&quot;desc&quot;, &quot;foreignObject&quot;, &quot;title&quot;};</span>

    public static final int MaxScopeSearchDepth = 100; // prevents the parser bogging down in exceptionally broken pages

    private HtmlTreeBuilderState state; // the current state
    private HtmlTreeBuilderState originalState; // original / marked state

    private boolean baseUriSetFromDoc;
    private @Nullable Element headElement; // the current head element
    private @Nullable FormElement formElement; // the current form element
    private @Nullable Element contextElement; // fragment parse context -- could be null even if fragment parsing
    private ArrayList&lt;Element&gt; formattingElements; // active (open) formatting elements
    private ArrayList&lt;HtmlTreeBuilderState&gt; tmplInsertMode; // stack of Template Insertion modes
    private List&lt;Token.Character&gt; pendingTableCharacters; // chars in table to be shifted out
    private Token.EndTag emptyEnd; // reused empty end tag

    private boolean framesetOk; // if ok to go into frameset
    private boolean fosterInserts; // if next inserts should be fostered
    private boolean fragmentParsing; // if parsing a fragment of html

    @Override ParseSettings defaultSettings() {
<span id="H1">        return ParseSettings.htmlDefault;</span>
    }

    @Override
    HtmlTreeBuilder newInstance() {
<span id="H2">        return new HtmlTreeBuilder();</span>
    }

    @Override
    protected void initialiseParse(Reader input, String baseUri, Parser parser) {
<span id="H1">        super.initialiseParse(input, baseUri, parser);</span>

        // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.
<span id="H1">        state = HtmlTreeBuilderState.Initial;</span>
<span id="H1">        originalState = null;</span>
<span id="H1">        baseUriSetFromDoc = false;</span>
<span id="H1">        headElement = null;</span>
<span id="H1">        formElement = null;</span>
<span id="H1">        contextElement = null;</span>
<span id="H1">        formattingElements = new ArrayList&lt;&gt;();</span>
<span id="H1">        tmplInsertMode = new ArrayList&lt;&gt;();</span>
<span id="H1">        pendingTableCharacters = new ArrayList&lt;&gt;();</span>
<span id="H1">        emptyEnd = new Token.EndTag(this);</span>
<span id="H1">        framesetOk = true;</span>
<span id="H1">        fosterInserts = false;</span>
<span id="H1">        fragmentParsing = false;</span>
<span id="H1">    }</span>

    @Override List&lt;Node&gt; parseFragment(String inputFragment, @Nullable Element context, String baseUri, Parser parser) {
        // context may be null
<span id="H1">        state = HtmlTreeBuilderState.Initial;</span>
<span id="H1">        initialiseParse(new StringReader(inputFragment), baseUri, parser);</span>
<span id="H1">        contextElement = context;</span>
<span id="H1">        fragmentParsing = true;</span>
<span id="H1">        Element root = null;</span>

<span id="H1">        if (context != null) {</span>
<span id="H2">            if (context.ownerDocument() != null) // quirks setup:</span>
<span id="H2">                doc.quirksMode(context.ownerDocument().quirksMode());</span>

            // initialise the tokeniser state:
<span id="H2">            String contextTag = context.normalName();</span>
<span id="H2">            switch (contextTag) {</span>
                case &quot;title&quot;:
                case &quot;textarea&quot;:
<span id="H2">                    tokeniser.transition(TokeniserState.Rcdata);</span>
<span id="H2">                    break;</span>
                case &quot;iframe&quot;:
                case &quot;noembed&quot;:
                case &quot;noframes&quot;:
                case &quot;style&quot;:
                case &quot;xmp&quot;:
<span id="H2">                    tokeniser.transition(TokeniserState.Rawtext);</span>
<span id="H2">                    break;</span>
                case &quot;script&quot;:
<span id="H2">                    tokeniser.transition(TokeniserState.ScriptData);</span>
<span id="H2">                    break;</span>
                case &quot;plaintext&quot;:
                    tokeniser.transition(TokeniserState.PLAINTEXT);
                    break;
                case &quot;template&quot;:
<span id="H2">                    tokeniser.transition(TokeniserState.Data);</span>
<span id="H2">                    pushTemplateMode(HtmlTreeBuilderState.InTemplate);</span>
<span id="H2">                    break;</span>
                default:
<span id="H2">                    tokeniser.transition(TokeniserState.Data);</span>
            }
<span id="H2">            root = new Element(tagFor(contextTag, settings), baseUri);</span>
<span id="H2">            doc.appendChild(root);</span>
<span id="H2">            push(root);</span>
<span id="H2">            resetInsertionMode();</span>

            // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated
            // with form correctly
<span id="H2">            Element formSearch = context;</span>
<span id="H2">            while (formSearch != null) {</span>
<span id="H2">                if (formSearch instanceof FormElement) {</span>
<span id="H2">                    formElement = (FormElement) formSearch;</span>
<span id="H2">                    break;</span>
                }
<span id="H2">                formSearch = formSearch.parent();</span>
            }
        }

<span id="H1">        runParser();</span>
<span id="H1">        if (context != null) {</span>
            // depending on context and the input html, content may have been added outside of the root el
            // e.g. context=p, input=div, the div will have been pushed out.
<span id="H2">            List&lt;Node&gt; nodes = root.siblingNodes();</span>
<span id="H2">            if (!nodes.isEmpty())</span>
<span id="H2">                root.insertChildren(-1, nodes);</span>
<span id="H2">            return root.childNodes();</span>
        }
        else
<span id="H1">            return doc.childNodes();</span>
    }

    @Override
    protected boolean process(Token token) {
<span id="H1">        HtmlTreeBuilderState dispatch = useCurrentOrForeignInsert(token) ? this.state : ForeignContent;</span>
<span id="H1">        return dispatch.process(token, this);</span>
    }

    boolean useCurrentOrForeignInsert(Token token) {
        // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction
        // If the stack of open elements is empty
<span id="H1">        if (stack.isEmpty())</span>
<span id="H1">            return true;</span>
<span id="H1">        final Element el = currentElement();</span>
<span id="H1">        final String ns = el.tag().namespace();</span>

        // If the adjusted current node is an element in the HTML namespace
<span id="H1">        if (NamespaceHtml.equals(ns))</span>
<span id="H1">            return true;</span>

        // If the adjusted current node is a MathML text integration point and the token is a start tag whose tag name is neither &quot;mglyph&quot; nor &quot;malignmark&quot;
        // If the adjusted current node is a MathML text integration point and the token is a character token
<span id="H1">        if (isMathmlTextIntegration(el)) {</span>
<span id="H2">            if (token.isStartTag()</span>
<span id="H2">                    &amp;&amp; !&quot;mglyph&quot;.equals(token.asStartTag().normalName)</span>
<span id="H2">                    &amp;&amp; !&quot;malignmark&quot;.equals(token.asStartTag().normalName))</span>
<span id="H2">                    return true;</span>
<span id="H2">            if (token.isCharacter())</span>
                    return true;
        }
        // If the adjusted current node is a MathML annotation-xml element and the token is a start tag whose tag name is &quot;svg&quot;
<span id="H1">        if (Parser.NamespaceMathml.equals(ns)</span>
<span id="H2">            &amp;&amp; el.normalName().equals(&quot;annotation-xml&quot;)</span>
<span id="H2">            &amp;&amp; token.isStartTag()</span>
<span id="H2">            &amp;&amp; &quot;svg&quot;.equals(token.asStartTag().normalName))</span>
<span id="H2">            return true;</span>

        // If the adjusted current node is an HTML integration point and the token is a start tag
        // If the adjusted current node is an HTML integration point and the token is a character token
<span id="H1">        if (isHtmlIntegration(el)</span>
<span id="H2">            &amp;&amp; (token.isStartTag() || token.isCharacter()))</span>
<span id="H2">            return true;</span>

        // If the token is an end-of-file token
<span id="H1">        return token.isEOF();</span>
    }

    static boolean isMathmlTextIntegration(Element el) {
        /*
        A node is a MathML text integration point if it is one of the following elements:
        A MathML mi element
        A MathML mo element
        A MathML mn element
        A MathML ms element
        A MathML mtext element
         */
<span id="H1">        return (Parser.NamespaceMathml.equals(el.tag().namespace())</span>
<span id="H1">            &amp;&amp; StringUtil.inSorted(el.normalName(), TagMathMlTextIntegration));</span>
    }

    static boolean isHtmlIntegration(Element el) {
        /*
        A node is an HTML integration point if it is one of the following elements:
        A MathML annotation-xml element whose start tag token had an attribute with the name &quot;encoding&quot; whose value was an ASCII case-insensitive match for the string &quot;text/html&quot;
        A MathML annotation-xml element whose start tag token had an attribute with the name &quot;encoding&quot; whose value was an ASCII case-insensitive match for the string &quot;application/xhtml+xml&quot;
        An SVG foreignObject element
        An SVG desc element
        An SVG title element
         */
<span id="H1">        if (Parser.NamespaceMathml.equals(el.tag().namespace())</span>
<span id="H2">            &amp;&amp; el.normalName().equals(&quot;annotation-xml&quot;)) {</span>
<span id="H2">            String encoding = Normalizer.normalize(el.attr(&quot;encoding&quot;));</span>
<span id="H2">            if (encoding.equals(&quot;text/html&quot;) || encoding.equals(&quot;application/xhtml+xml&quot;))</span>
<span id="H2">                return true;</span>
        }
<span id="H1">        if (Parser.NamespaceSvg.equals(el.tag().namespace())</span>
<span id="H1">            &amp;&amp; StringUtil.in(el.tagName(), TagSvgHtmlIntegration)) // note using .tagName for case-sensitive hit here of foreignObject</span>
<span id="H2">            return true;</span>

<span id="H1">        return false;</span>
    }

    boolean process(Token token, HtmlTreeBuilderState state) {
<span id="H2">        return state.process(token, this);</span>
    }

    void transition(HtmlTreeBuilderState state) {
<span id="H1">        this.state = state;</span>
<span id="H1">    }</span>

    HtmlTreeBuilderState state() {
<span id="H1">        return state;</span>
    }

    void markInsertionMode() {
<span id="H1">        originalState = state;</span>
<span id="H1">    }</span>

    HtmlTreeBuilderState originalState() {
<span id="H1">        return originalState;</span>
    }

    void framesetOk(boolean framesetOk) {
<span id="H1">        this.framesetOk = framesetOk;</span>
<span id="H1">    }</span>

    boolean framesetOk() {
<span id="H1">        return framesetOk;</span>
    }

    Document getDocument() {
<span id="H2">        return doc;</span>
    }

    String getBaseUri() {
<span id="H2">        return baseUri;</span>
    }

    void maybeSetBaseUri(Element base) {
<span id="H2">        if (baseUriSetFromDoc) // only listen to the first &lt;base href&gt; in parse</span>
<span id="H2">            return;</span>

<span id="H2">        String href = base.absUrl(&quot;href&quot;);</span>
<span id="H2">        if (href.length() != 0) { // ignore &lt;base target&gt; etc</span>
<span id="H2">            baseUri = href;</span>
<span id="H2">            baseUriSetFromDoc = true;</span>
<span id="H2">            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants</span>
        }
<span id="H2">    }</span>

    boolean isFragmentParsing() {
<span id="H1">        return fragmentParsing;</span>
    }

    void error(HtmlTreeBuilderState state) {
<span id="H1">        if (parser.getErrors().canAddError())</span>
<span id="H2">            parser.getErrors().add(new ParseError(reader, &quot;Unexpected %s token [%s] when in state [%s]&quot;,</span>
<span id="H2">                currentToken.tokenType(), currentToken, state));</span>
<span id="H1">    }</span>

    Element createElementFor(Token.StartTag startTag, String namespace, boolean forcePreserveCase) {
        // dedupe and normalize the attributes:
<span id="H1">        Attributes attributes = startTag.attributes;</span>
<span id="H1">        if (!forcePreserveCase)</span>
<span id="H1">            attributes = settings.normalizeAttributes(attributes);</span>
<span id="H1">        if (attributes != null &amp;&amp; !attributes.isEmpty()) {</span>
<span id="H1">            int dupes = attributes.deduplicate(settings);</span>
<span id="H1">            if (dupes &gt; 0) {</span>
<span id="H2">                error(&quot;Dropped duplicate attribute(s) in tag [%s]&quot;, startTag.normalName);</span>
            }
        }

<span id="H1">        Tag tag = tagFor(startTag.tagName, namespace,</span>
<span id="H1">            forcePreserveCase ? ParseSettings.preserveCase : settings);</span>

<span id="H1">        return (tag.normalName().equals(&quot;form&quot;)) ?</span>
<span id="H1">            new FormElement(tag, null, attributes) :</span>
<span id="H1">            new Element(tag, null, attributes);</span>
    }

    /** Inserts an HTML element for the given tag) */
    Element insertElementFor(final Token.StartTag startTag) {
<span id="H1">        Element el = createElementFor(startTag, NamespaceHtml, false);</span>
<span id="H1">        doInsertElement(el, startTag);</span>

        // handle self-closing tags. when the spec expects an empty tag, will directly hit insertEmpty, so won&#x27;t generate this fake end tag.
<span id="H1">        if (startTag.isSelfClosing()) {</span>
<span id="H1">            Tag tag = el.tag();</span>
<span id="H1">            if (tag.isKnownTag()) {</span>
<span id="H1">                if (!tag.isEmpty())</span>
<span id="H1">                    tokeniser.error(&quot;Tag [%s] cannot be self closing; not a void tag&quot;, tag.normalName());</span>
                // else: ok
            }
            else { // unknown tag: remember this is self-closing, for output
<span id="H2">                tag.setSelfClosing();</span>
            }

            // effectively a pop, but fiddles with the state. handles empty style, title etc which would otherwise leave us in data state
<span id="H1">            tokeniser.transition(TokeniserState.Data); // handles &lt;script /&gt;, otherwise needs breakout steps from script data</span>
<span id="H1">            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing</span>
        }

<span id="H1">        return el;</span>
    }

    /**
     Inserts a foreign element. Preserves the case of the tag name and of the attributes.
     */
    Element insertForeignElementFor(final Token.StartTag startTag, String namespace) {
<span id="H1">        Element el = createElementFor(startTag, namespace, true);</span>
<span id="H1">        doInsertElement(el, startTag);</span>

<span id="H1">        if (startTag.isSelfClosing()) {</span>
<span id="H1">            el.tag().setSelfClosing(); // remember this is self-closing for output</span>
<span id="H1">            pop();</span>
        }

<span id="H1">        return el;</span>
    }

    Element insertEmptyElementFor(Token.StartTag startTag) {
<span id="H1">        Element el = createElementFor(startTag, NamespaceHtml, false);</span>
<span id="H1">        doInsertElement(el, startTag);</span>
<span id="H1">        pop();</span>
<span id="H1">        return el;</span>
    }

    FormElement insertFormElement(Token.StartTag startTag, boolean onStack, boolean checkTemplateStack) {
<span id="H1">        FormElement el = (FormElement) createElementFor(startTag, NamespaceHtml, false);</span>

<span id="H1">        if (checkTemplateStack) {</span>
<span id="H1">            if(!onStack(&quot;template&quot;))</span>
<span id="H1">                setFormElement(el);</span>
        } else
<span id="H2">            setFormElement(el);</span>

<span id="H1">        doInsertElement(el, startTag);</span>
<span id="H1">        if (!onStack) pop();</span>
<span id="H1">        return el;</span>
    }

    /** Inserts the Element onto the stack. All element inserts must run through this method. Performs any general
     tests on the Element before insertion.
     * @param el the Element to insert and make the current element
     * @param token the token this element was parsed from. If null, uses a zero-width current token as intrinsic insert
     */
    private void doInsertElement(Element el, @Nullable Token token) {
<span id="H1">        if (el.tag().isFormListed() &amp;&amp; formElement != null)</span>
<span id="H2">            formElement.addElement(el); // connect form controls to their form element</span>

        // in HTML, the xmlns attribute if set must match what the parser set the tag&#x27;s namespace to
<span id="H1">        if (el.hasAttr(&quot;xmlns&quot;) &amp;&amp; !el.attr(&quot;xmlns&quot;).equals(el.tag().namespace()))</span>
<span id="H2">            error(&quot;Invalid xmlns attribute [%s] on tag [%s]&quot;, el.attr(&quot;xmlns&quot;), el.tagName());</span>

<span id="H1">        if (isFosterInserts() &amp;&amp; StringUtil.inSorted(currentElement().normalName(), InTableFoster))</span>
<span id="H2">            insertInFosterParent(el);</span>
        else
<span id="H1">            currentElement().appendChild(el);</span>

<span id="H1">        push(el);</span>
<span id="H1">    }</span>

    void insertCommentNode(Token.Comment token) {
<span id="H1">        Comment node = new Comment(token.getData());</span>
<span id="H1">        currentElement().appendChild(node);</span>
<span id="H1">        onNodeInserted(node);</span>
<span id="H1">    }</span>

    /** Inserts the provided character token into the current element. */
    void insertCharacterNode(Token.Character characterToken) {
<span id="H1">        Element el = currentElement(); // will be doc if no current element; allows for whitespace to be inserted into the doc root object (not on the stack)</span>
<span id="H1">        insertCharacterToElement(characterToken, el);</span>
<span id="H1">    }</span>

    /** Inserts the provided character token into the provided element. */
    void insertCharacterToElement(Token.Character characterToken, Element el) {
        final Node node;
<span id="H1">        final String tagName = el.normalName();</span>
<span id="H1">        final String data = characterToken.getData();</span>

<span id="H1">        if (characterToken.isCData())</span>
<span id="H2">            node = new CDataNode(data);</span>
<span id="H1">        else if (isContentForTagData(tagName))</span>
<span id="H2">            node = new DataNode(data);</span>
        else
<span id="H1">            node = new TextNode(data);</span>
<span id="H1">        el.appendChild(node); // doesn&#x27;t use insertNode, because we don&#x27;t foster these; and will always have a stack.</span>
<span id="H1">        onNodeInserted(node);</span>
<span id="H1">    }</span>

    ArrayList&lt;Element&gt; getStack() {
<span id="H1">        return stack;</span>
    }

    boolean onStack(Element el) {
<span id="H1">        return onStack(stack, el);</span>
    }

    /** Checks if there is an HTML element with the given name on the stack. */
    boolean onStack(String elName) {
<span id="H1">        return getFromStack(elName) != null;</span>
    }

    private static final int maxQueueDepth = 256; // an arbitrary tension point between real HTML and crafted pain
    private static boolean onStack(ArrayList&lt;Element&gt; queue, Element element) {
<span id="H1">        final int bottom = queue.size() - 1;</span>
<span id="H1">        final int upper = bottom &gt;= maxQueueDepth ? bottom - maxQueueDepth : 0;</span>
<span id="H1">        for (int pos = bottom; pos &gt;= upper; pos--) {</span>
<span id="H1">            Element next = queue.get(pos);</span>
<span id="H1">            if (next == element) {</span>
<span id="H1">                return true;</span>
            }
        }
<span id="H2">        return false;</span>
    }

    /** Gets the nearest (lowest) HTML element with the given name from the stack. */
    @Nullable
    Element getFromStack(String elName) {
<span id="H1">        final int bottom = stack.size() - 1;</span>
<span id="H1">        final int upper = bottom &gt;= maxQueueDepth ? bottom - maxQueueDepth : 0;</span>
<span id="H1">        for (int pos = bottom; pos &gt;= upper; pos--) {</span>
<span id="H1">            Element next = stack.get(pos);</span>
<span id="H1">            if (next.normalName().equals(elName) &amp;&amp; NamespaceHtml.equals(next.tag().namespace())) {</span>
<span id="H1">                return next;</span>
            }
        }
<span id="H1">        return null;</span>
    }

    boolean removeFromStack(Element el) {
<span id="H2">        for (int pos = stack.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H2">            Element next = stack.get(pos);</span>
<span id="H2">            if (next == el) {</span>
<span id="H2">                stack.remove(pos);</span>
<span id="H2">                onNodeClosed(el);</span>
<span id="H2">                return true;</span>
            }
        }
        return false;
    }

    /** Pops the stack until the given HTML element is removed. */
    @Nullable
    Element popStackToClose(String elName) {
<span id="H1">        for (int pos = stack.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H1">            Element el = pop();</span>
<span id="H1">            if (el.normalName().equals(elName) &amp;&amp; NamespaceHtml.equals(el.tag().namespace())) {</span>
<span id="H1">                return el;</span>
            }
        }
        return null;
    }

    /** Pops the stack until an element with the supplied name is removed, irrespective of namespace. */
    @Nullable
    Element popStackToCloseAnyNamespace(String elName) {
<span id="H1">        for (int pos = stack.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H1">            Element el = pop();</span>
<span id="H1">            if (el.normalName().equals(elName)) {</span>
<span id="H1">                return el;</span>
            }
        }
        return null;
    }

    /** Pops the stack until one of the given HTML elements is removed. */
    void popStackToClose(String... elNames) { // elnames is sorted, comes from Constants
<span id="H2">        for (int pos = stack.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H2">            Element el = pop();</span>
<span id="H2">            if (inSorted(el.normalName(), elNames) &amp;&amp; NamespaceHtml.equals(el.tag().namespace())) {</span>
<span id="H2">                break;</span>
            }
        }
<span id="H2">    }</span>

    void clearStackToTableContext() {
<span id="H2">        clearStackToContext(&quot;table&quot;, &quot;template&quot;);</span>
<span id="H2">    }</span>

    void clearStackToTableBodyContext() {
<span id="H2">        clearStackToContext(&quot;tbody&quot;, &quot;tfoot&quot;, &quot;thead&quot;, &quot;template&quot;);</span>
<span id="H2">    }</span>

    void clearStackToTableRowContext() {
<span id="H2">        clearStackToContext(&quot;tr&quot;, &quot;template&quot;);</span>
<span id="H2">    }</span>

    /** Removes elements from the stack until one of the supplied HTML elements is removed. */
    private void clearStackToContext(String... nodeNames) {
<span id="H2">        for (int pos = stack.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H2">            Element next = stack.get(pos);</span>
<span id="H2">            if (NamespaceHtml.equals(next.tag().namespace()) &amp;&amp;</span>
<span id="H2">                (StringUtil.in(next.normalName(), nodeNames) || next.normalName().equals(&quot;html&quot;)))</span>
                break;
            else
<span id="H2">                pop();</span>
        }
<span id="H2">    }</span>

    @Nullable Element aboveOnStack(Element el) {
<span id="H2">        assert onStack(el);</span>
<span id="H2">        for (int pos = stack.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H2">            Element next = stack.get(pos);</span>
<span id="H2">            if (next == el) {</span>
<span id="H2">                return stack.get(pos-1);</span>
            }
        }
        return null;
    }

    void insertOnStackAfter(Element after, Element in) {
<span id="H2">        int i = stack.lastIndexOf(after);</span>
<span id="H2">        Validate.isTrue(i != -1);</span>
<span id="H2">        stack.add(i+1, in);</span>
<span id="H2">    }</span>

    void replaceOnStack(Element out, Element in) {
<span id="H2">        replaceInQueue(stack, out, in);</span>
<span id="H2">    }</span>

    private static void replaceInQueue(ArrayList&lt;Element&gt; queue, Element out, Element in) {
<span id="H2">        int i = queue.lastIndexOf(out);</span>
<span id="H2">        Validate.isTrue(i != -1);</span>
<span id="H2">        queue.set(i, in);</span>
<span id="H2">    }</span>

    /**
     * Reset the insertion mode, by searching up the stack for an appropriate insertion mode. The stack search depth
     * is limited to {@link #maxQueueDepth}.
     * @return true if the insertion mode was actually changed.
     */
    boolean resetInsertionMode() {
        // https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode
<span id="H1">        boolean last = false;</span>
<span id="H1">        final int bottom = stack.size() - 1;</span>
<span id="H1">        final int upper = bottom &gt;= maxQueueDepth ? bottom - maxQueueDepth : 0;</span>
<span id="H1">        final HtmlTreeBuilderState origState = this.state;</span>

<span id="H1">        if (stack.size() == 0) { // nothing left of stack, just get to body</span>
            transition(HtmlTreeBuilderState.InBody);
        }

<span id="H1">        LOOP: for (int pos = bottom; pos &gt;= upper; pos--) {</span>
<span id="H1">            Element node = stack.get(pos);</span>
<span id="H1">            if (pos == upper) {</span>
<span id="H2">                last = true;</span>
<span id="H2">                if (fragmentParsing)</span>
<span id="H2">                    node = contextElement;</span>
            }
<span id="H1">            String name = node != null ? node.normalName() : &quot;&quot;;</span>
<span id="H1">            if (!NamespaceHtml.equals(node.tag().namespace()))</span>
                continue; // only looking for HTML elements here

<span id="H1">            switch (name) {</span>
                case &quot;select&quot;:
                    transition(HtmlTreeBuilderState.InSelect);
                    // todo - should loop up (with some limit) and check for table or template hits
                    break LOOP;
                case &quot;td&quot;:
                case &quot;th&quot;:
<span id="H2">                    if (!last) {</span>
<span id="H2">                        transition(HtmlTreeBuilderState.InCell);</span>
<span id="H2">                        break LOOP;</span>
                    }
                    break;
                case &quot;tr&quot;:
<span id="H2">                    transition(HtmlTreeBuilderState.InRow);</span>
<span id="H2">                    break LOOP;</span>
                case &quot;tbody&quot;:
                case &quot;thead&quot;:
                case &quot;tfoot&quot;:
<span id="H2">                    transition(HtmlTreeBuilderState.InTableBody);</span>
<span id="H2">                    break LOOP;</span>
                case &quot;caption&quot;:
                    transition(HtmlTreeBuilderState.InCaption);
                    break LOOP;
                case &quot;colgroup&quot;:
                    transition(HtmlTreeBuilderState.InColumnGroup);
                    break LOOP;
                case &quot;table&quot;:
<span id="H2">                    transition(HtmlTreeBuilderState.InTable);</span>
<span id="H2">                    break LOOP;</span>
                case &quot;template&quot;:
<span id="H2">                    HtmlTreeBuilderState tmplState = currentTemplateMode();</span>
<span id="H2">                    Validate.notNull(tmplState, &quot;Bug: no template insertion mode on stack!&quot;);</span>
<span id="H2">                    transition(tmplState);</span>
<span id="H2">                    break LOOP;</span>
                case &quot;head&quot;:
<span id="H2">                    if (!last) {</span>
<span id="H2">                        transition(HtmlTreeBuilderState.InHead);</span>
<span id="H2">                        break LOOP;</span>
                    }
                    break;
                case &quot;body&quot;:
<span id="H1">                    transition(HtmlTreeBuilderState.InBody);</span>
<span id="H1">                    break LOOP;</span>
                case &quot;frameset&quot;:
                    transition(HtmlTreeBuilderState.InFrameset);
                    break LOOP;
                case &quot;html&quot;:
                    transition(headElement == null ? HtmlTreeBuilderState.BeforeHead : HtmlTreeBuilderState.AfterHead);
                    break LOOP;
            }
<span id="H2">            if (last) {</span>
<span id="H2">                transition(HtmlTreeBuilderState.InBody);</span>
<span id="H2">                break;</span>
            }
        }
<span id="H1">        return state != origState;</span>
    }

    /** Places the body back onto the stack and moves to InBody, for cases in AfterBody / AfterAfterBody when more content comes */
    void resetBody() {
<span id="H2">        if (!onStack(&quot;body&quot;)) {</span>
            stack.add(doc.body()); // not onNodeInserted, as already seen
        }
<span id="H2">        transition(HtmlTreeBuilderState.InBody);</span>
<span id="H2">    }</span>

    // todo: tidy up in specific scope methods
<span id="H1">    private final String[] specificScopeTarget = {null};</span>

    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {
<span id="H1">        specificScopeTarget[0] = targetName;</span>
<span id="H1">        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);</span>
    }

    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, @Nullable String[] extraTypes) {
        // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope
<span id="H1">        final int bottom = stack.size() -1;</span>
<span id="H1">        final int top = bottom &gt; MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;</span>
        // don&#x27;t walk too far up the tree

<span id="H1">        for (int pos = bottom; pos &gt;= top; pos--) {</span>
<span id="H1">            Element el = stack.get(pos);</span>
<span id="H1">            if (!el.tag().namespace().equals(NamespaceHtml)) continue;</span>

<span id="H1">            final String elName = el.normalName();</span>
<span id="H1">            if (inSorted(elName, targetNames))</span>
<span id="H1">                return true;</span>
<span id="H1">            if (inSorted(elName, baseTypes))</span>
<span id="H1">                return false;</span>
<span id="H1">            if (extraTypes != null &amp;&amp; inSorted(elName, extraTypes))</span>
<span id="H2">                return false;</span>
        }
        //Validate.fail(&quot;Should not be reachable&quot;); // would end up false because hitting &#x27;html&#x27; at root (basetypes)
<span id="H2">        return false;</span>
    }

    boolean inScope(String[] targetNames) {
<span id="H2">        return inSpecificScope(targetNames, TagsSearchInScope, null);</span>
    }

    boolean inScope(String targetName) {
<span id="H1">        return inScope(targetName, null);</span>
    }

    boolean inScope(String targetName, String[] extras) {
<span id="H1">        return inSpecificScope(targetName, TagsSearchInScope, extras);</span>
        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml
        // todo: in svg namespace: forignOjbect, desc, title
    }

    boolean inListItemScope(String targetName) {
<span id="H2">        return inScope(targetName, TagSearchList);</span>
    }

    boolean inButtonScope(String targetName) {
<span id="H1">        return inScope(targetName, TagSearchButton);</span>
    }

    boolean inTableScope(String targetName) {
<span id="H2">        return inSpecificScope(targetName, TagSearchTableScope, null);</span>
    }

    boolean inSelectScope(String targetName) {
<span id="H1">        for (int pos = stack.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H1">            Element el = stack.get(pos);</span>
<span id="H1">            String elName = el.normalName();</span>
<span id="H1">            if (elName.equals(targetName))</span>
<span id="H1">                return true;</span>
<span id="H2">            if (!inSorted(elName, TagSearchSelectScope)) // all elements except</span>
                return false;
        }
        Validate.fail(&quot;Should not be reachable&quot;);
        return false;
    }

    /** Tests if there is some element on the stack that is not in the provided set. */
    boolean onStackNot(String[] allowedTags) {
<span id="H1">        final int bottom = stack.size() -1;</span>
<span id="H1">        final int top = bottom &gt; MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;</span>
        // don&#x27;t walk too far up the tree

<span id="H1">        for (int pos = bottom; pos &gt;= top; pos--) {</span>
<span id="H1">            final String elName = stack.get(pos).normalName();</span>
<span id="H1">            if (!inSorted(elName, allowedTags))</span>
<span id="H1">                return true;</span>
        }
<span id="H1">        return false;</span>
    }

    void setHeadElement(Element headElement) {
<span id="H1">        this.headElement = headElement;</span>
<span id="H1">    }</span>

    Element getHeadElement() {
<span id="H2">        return headElement;</span>
    }

    boolean isFosterInserts() {
<span id="H1">        return fosterInserts;</span>
    }

    void setFosterInserts(boolean fosterInserts) {
<span id="H2">        this.fosterInserts = fosterInserts;</span>
<span id="H2">    }</span>

    @Nullable FormElement getFormElement() {
<span id="H1">        return formElement;</span>
    }

    void setFormElement(FormElement formElement) {
<span id="H1">        this.formElement = formElement;</span>
<span id="H1">    }</span>

    void resetPendingTableCharacters() {
<span id="H2">        pendingTableCharacters.clear();</span>
<span id="H2">    }</span>

    List&lt;Token.Character&gt; getPendingTableCharacters() {
<span id="H2">        return pendingTableCharacters;</span>
    }

    void addPendingTableCharacters(Token.Character c) {
        // make a clone of the token to maintain its state (as Tokens are otherwise reset)
<span id="H2">        Token.Character clone = c.clone();</span>
<span id="H2">        pendingTableCharacters.add(clone);</span>
<span id="H2">    }</span>

    /**
     13.2.6.3 Closing elements that have implied end tags
     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.

     If a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.

     When the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.

     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the
     process, then the UA must perform the above steps as if that element was not in the above list.
     */
    void generateImpliedEndTags(String excludeTag) {
<span id="H2">        while (inSorted(currentElement().normalName(), TagSearchEndTags)) {</span>
<span id="H2">            if (excludeTag != null &amp;&amp; currentElementIs(excludeTag))</span>
<span id="H2">                break;</span>
<span id="H2">            pop();</span>
        }
<span id="H2">    }</span>

    void generateImpliedEndTags() {
<span id="H1">        generateImpliedEndTags(false);</span>
<span id="H1">    }</span>

    /**
     Pops HTML elements off the stack according to the implied end tag rules
     @param thorough if we are thorough (includes table elements etc) or not
     */
    void generateImpliedEndTags(boolean thorough) {
<span id="H1">        final String[] search = thorough ? TagThoroughSearchEndTags : TagSearchEndTags;</span>
<span id="H1">        while (NamespaceHtml.equals(currentElement().tag().namespace())</span>
<span id="H1">            &amp;&amp; inSorted(currentElement().normalName(), search)) {</span>
<span id="H2">            pop();</span>
        }
<span id="H1">    }</span>

    void closeElement(String name) {
        generateImpliedEndTags(name);
        if (!name.equals(currentElement().normalName())) error(state());
        popStackToClose(name);
    }

    static boolean isSpecial(Element el) {
        // todo: mathml&#x27;s mi, mo, mn
        // todo: svg&#x27;s foreigObject, desc, title
<span id="H2">        String name = el.normalName();</span>
<span id="H2">        return inSorted(name, TagSearchSpecial);</span>
    }

    Element lastFormattingElement() {
<span id="H1">        return formattingElements.size() &gt; 0 ? formattingElements.get(formattingElements.size()-1) : null;</span>
    }

    int positionOfElement(Element el){
<span id="H1">        for (int i = 0; i &lt; formattingElements.size(); i++){</span>
<span id="H1">            if (el == formattingElements.get(i))</span>
<span id="H1">                return i;</span>
        }
        return -1;
    }

    Element removeLastFormattingElement() {
<span id="H2">        int size = formattingElements.size();</span>
<span id="H2">        if (size &gt; 0)</span>
<span id="H2">            return formattingElements.remove(size-1);</span>
        else
            return null;
    }

    // active formatting elements
    void pushActiveFormattingElements(Element in) {
<span id="H1">        checkActiveFormattingElements(in);</span>
<span id="H1">        formattingElements.add(in);</span>
<span id="H1">    }</span>

    void pushWithBookmark(Element in, int bookmark){
<span id="H2">        checkActiveFormattingElements(in);</span>
        // catch any range errors and assume bookmark is incorrect - saves a redundant range check.
        try {
<span id="H2">            formattingElements.add(bookmark, in);</span>
<span id="H2">        } catch (IndexOutOfBoundsException e) {</span>
<span id="H2">            formattingElements.add(in);</span>
<span id="H2">        }</span>
<span id="H2">    }</span>

    void checkActiveFormattingElements(Element in){
<span id="H1">        int numSeen = 0;</span>
<span id="H1">        final int size = formattingElements.size() -1;</span>
<span id="H1">        int ceil = size - maxUsedFormattingElements; if (ceil &lt;0) ceil = 0;</span>

<span id="H1">        for (int pos = size; pos &gt;= ceil; pos--) {</span>
<span id="H2">            Element el = formattingElements.get(pos);</span>
<span id="H2">            if (el == null) // marker</span>
<span id="H2">                break;</span>

<span id="H2">            if (isSameFormattingElement(in, el))</span>
<span id="H2">                numSeen++;</span>

<span id="H2">            if (numSeen == 3) {</span>
<span id="H4">                formattingElements.remove(pos);</span>
<span id="H4">                break;</span>
            }
        }
<span id="H1">    }</span>

    private static boolean isSameFormattingElement(Element a, Element b) {
        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children
<span id="H2">        return a.normalName().equals(b.normalName()) &amp;&amp;</span>
                // a.namespace().equals(b.namespace()) &amp;&amp;
<span id="H2">                a.attributes().equals(b.attributes());</span>
        // todo: namespaces
    }

    void reconstructFormattingElements() {
<span id="H1">        if (stack.size() &gt; maxQueueDepth)</span>
<span id="H2">            return;</span>
<span id="H1">        Element last = lastFormattingElement();</span>
<span id="H1">        if (last == null || onStack(last))</span>
<span id="H1">            return;</span>

<span id="H2">        Element entry = last;</span>
<span id="H2">        int size = formattingElements.size();</span>
<span id="H2">        int ceil = size - maxUsedFormattingElements; if (ceil &lt;0) ceil = 0;</span>
<span id="H2">        int pos = size - 1;</span>
<span id="H2">        boolean skip = false;</span>
        while (true) {
<span id="H2">            if (pos == ceil) { // step 4. if none before, skip to 8</span>
<span id="H2">                skip = true;</span>
<span id="H2">                break;</span>
            }
<span id="H2">            entry = formattingElements.get(--pos); // step 5. one earlier than entry</span>
<span id="H2">            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack</span>
<span id="H2">                break; // jump to 8, else continue back to 4</span>
        }
        while(true) {
<span id="H2">            if (!skip) // step 7: on later than entry</span>
<span id="H2">                entry = formattingElements.get(++pos);</span>
<span id="H2">            Validate.notNull(entry); // should not occur, as we break at last element</span>

            // 8. create new element from element, 9 insert into current node, onto stack
<span id="H2">            skip = false; // can only skip increment from 4.</span>
<span id="H2">            Element newEl = new Element(tagFor(entry.normalName(), settings), null, entry.attributes().clone());</span>
<span id="H2">            doInsertElement(newEl, null);</span>

            // 10. replace entry with new entry
<span id="H2">            formattingElements.set(pos, newEl);</span>

            // 11
<span id="H2">            if (pos == size-1) // if not last entry in list, jump to 7</span>
<span id="H2">                break;</span>
<span id="H2">        }</span>
<span id="H2">    }</span>
    private static final int maxUsedFormattingElements = 12; // limit how many elements get recreated

    void clearFormattingElementsToLastMarker() {
<span id="H2">        while (!formattingElements.isEmpty()) {</span>
<span id="H2">            Element el = removeLastFormattingElement();</span>
<span id="H2">            if (el == null)</span>
<span id="H2">                break;</span>
        }
<span id="H2">    }</span>

    void removeFromActiveFormattingElements(Element el) {
<span id="H1">        for (int pos = formattingElements.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H1">            Element next = formattingElements.get(pos);</span>
<span id="H1">            if (next == el) {</span>
<span id="H1">                formattingElements.remove(pos);</span>
<span id="H1">                break;</span>
            }
        }
<span id="H1">    }</span>

    boolean isInActiveFormattingElements(Element el) {
<span id="H2">        return onStack(formattingElements, el);</span>
    }

    @Nullable
    Element getActiveFormattingElement(String nodeName) {
<span id="H1">        for (int pos = formattingElements.size() -1; pos &gt;= 0; pos--) {</span>
<span id="H1">            Element next = formattingElements.get(pos);</span>
<span id="H1">            if (next == null) // scope marker</span>
<span id="H2">                break;</span>
<span id="H1">            else if (next.normalName().equals(nodeName))</span>
<span id="H1">                return next;</span>
        }
<span id="H1">        return null;</span>
    }

    void replaceActiveFormattingElement(Element out, Element in) {
<span id="H2">        replaceInQueue(formattingElements, out, in);</span>
<span id="H2">    }</span>

    void insertMarkerToFormattingElements() {
<span id="H2">        formattingElements.add(null);</span>
<span id="H2">    }</span>

    void insertInFosterParent(Node in) {
        Element fosterParent;
<span id="H2">        Element lastTable = getFromStack(&quot;table&quot;);</span>
<span id="H2">        boolean isLastTableParent = false;</span>
<span id="H2">        if (lastTable != null) {</span>
<span id="H2">            if (lastTable.parent() != null) {</span>
<span id="H2">                fosterParent = lastTable.parent();</span>
<span id="H2">                isLastTableParent = true;</span>
            } else
                fosterParent = aboveOnStack(lastTable);
        } else { // no table == frag
            fosterParent = stack.get(0);
        }

<span id="H2">        if (isLastTableParent) {</span>
<span id="H2">            Validate.notNull(lastTable); // last table cannot be null by this point.</span>
<span id="H2">            lastTable.before(in);</span>
        }
        else
            fosterParent.appendChild(in);
<span id="H2">    }</span>

    // Template Insertion Mode stack
    void pushTemplateMode(HtmlTreeBuilderState state) {
<span id="H2">        tmplInsertMode.add(state);</span>
<span id="H2">    }</span>

    @Nullable HtmlTreeBuilderState popTemplateMode() {
<span id="H2">        if (tmplInsertMode.size() &gt; 0) {</span>
<span id="H2">            return tmplInsertMode.remove(tmplInsertMode.size() -1);</span>
        } else {
            return null;
        }
    }

    int templateModeSize() {
<span id="H1">        return tmplInsertMode.size();</span>
    }

    @Nullable HtmlTreeBuilderState currentTemplateMode() {
<span id="H2">        return (tmplInsertMode.size() &gt; 0) ? tmplInsertMode.get(tmplInsertMode.size() -1)  : null;</span>
    }

    @Override
    public String toString() {
        return &quot;TreeBuilder{&quot; +
                &quot;currentToken=&quot; + currentToken +
                &quot;, state=&quot; + state +
                &quot;, currentElement=&quot; + currentElement() +
                &#x27;}&#x27;;
    }

    @Override protected boolean isContentForTagData(final String normalName) {
<span id="H1">        return (normalName.equals(&quot;script&quot;) || normalName.equals(&quot;style&quot;));</span>
    }
}</pre>
</div>
<script src="../../../../../../__resource__/prettify.js"></script>
</body>
</html>
